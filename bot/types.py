"""Shared data types for the Polymarket bot."""

from __future__ import annotations

import asyncio
from dataclasses import dataclass, field
from datetime import datetime, timezone

from bot.constants import EventType, OrderStatus, OrderType, Side, Strategy


@dataclass(frozen=True)
class Signal:
    """A trade signal generated by a strategy."""
    strategy: Strategy
    token_id: str
    condition_id: str
    side: Side
    price: float
    size: float
    order_type: OrderType = OrderType.GTC
    reason: str = ""
    edge: float | None = None
    confidence: float | None = None
    market_question: str = ""


@dataclass
class OrderResult:
    """Result of an order execution attempt."""
    signal: Signal
    success: bool
    order_id: str | None = None
    fill_price: float | None = None
    fill_size: float | None = None
    fee_paid: float = 0.0
    error: str | None = None
    is_dry_run: bool = True
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


@dataclass(frozen=True)
class OrderBookLevel:
    """A single level in an order book."""
    price: float
    size: float


@dataclass
class OrderBook:
    """Order book snapshot for a token."""
    token_id: str
    bids: list[OrderBookLevel] = field(default_factory=list)
    asks: list[OrderBookLevel] = field(default_factory=list)
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))

    @property
    def best_bid(self) -> float | None:
        return self.bids[0].price if self.bids else None

    @property
    def best_ask(self) -> float | None:
        return self.asks[0].price if self.asks else None

    @property
    def midpoint(self) -> float | None:
        if self.best_bid is not None and self.best_ask is not None:
            return (self.best_bid + self.best_ask) / 2
        return None

    @property
    def spread(self) -> float | None:
        if self.best_bid is not None and self.best_ask is not None:
            return self.best_ask - self.best_bid
        return None


@dataclass
class Market:
    """Polymarket market metadata."""
    condition_id: str
    question: str
    tokens: list[TokenInfo]
    active: bool = True
    min_incentive_size: float = 0.0
    max_incentive_spread: float = 0.0
    category: str = ""
    end_date: str | None = None
    daily_reward_usd: float = 0.0
    competition_level: str = ""  # "mild", "moderate", "fierce"
    competitive_raw: float = 0.5   # Raw competitive score (0-1) from API
    volume_24h: float = 0.0       # 24h trading volume in USD
    liquidity: float = 0.0         # Total order book liquidity in USD
    spread: float = 1.0            # Current bid-ask spread (0-1)
    best_bid: float = 0.0          # Current best bid price
    best_ask: float = 0.0          # Current best ask price


@dataclass(frozen=True)
class TokenInfo:
    """Token info within a market."""
    token_id: str
    outcome: str  # "Yes" or "No"
    price: float = 0.0


@dataclass
class Position:
    """A held position in a market."""
    condition_id: str
    token_id: str
    outcome: str
    size: float
    avg_entry_price: float
    strategy: Strategy
    current_price: float = 0.0
    unrealized_pnl: float = 0.0


@dataclass
class BotEvent:
    """Event published by the engine to dashboard/notifications."""
    type: EventType
    data: dict
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


# Type alias for the event bus
EventBus = asyncio.Queue[BotEvent]


@dataclass
class RiskVerdict:
    """Result of a risk check."""
    allowed: bool
    adjusted_signal: Signal | None = None  # Signal with adjusted size if needed
    reason: str = ""


@dataclass
class SynthForecast:
    """Synth API probability forecast for a crypto asset."""
    asset: str
    synth_prob_up: float
    poly_prob_up: float
    edge: float
    up_token_id: str = ""
    down_token_id: str = ""
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
